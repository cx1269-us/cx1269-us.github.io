[{"title":"c++ Primer Plus","url":"/2022/07/10/c-Primer-Plus/","content":"C++ primer PLus面向对象编程面向过程类：在C++中, 用 “类“ 来描述 “对象“, 所谓的”对象”是指现实世界中的一切事物。类是属于用户自定义的数据类型, 并且该类型的数据具有一定的行为能力, 也就是类中说描述的方法。通常来说, 一个类的定义包含两部分的内容, 一是该类的属性, 另一部分是它所拥有的方法。\n泛型编程(generic programming)：是C++支持的另一种编程模式。它与OOP的目标相同，即使重用代码和抽象通用概念的技术更简单。不过OOP强调的是编程的数据方面，而泛型编程强调的是独立于特定数据类型。它们的侧重点不同。OOP是一个管理大型项目的工具，而泛型编程提供了执行常见任务(如对数据排序或合并链表）的工具。术语泛型(generic）指的是创建独立于类型的代码。C++的数据表示有多种类型——整数、小数、字符、字符串、用户定义的、由多种类型组成的复合结构。例如，要对不同类型的数据进行排序，通常必须为每种类型创建一个排序函数。泛型编程需要对语言进行扩展，以便可以只编写一个泛型(即不是特定类型的）函数，并将其用于各种实际类型。C++模板提供了完成这种任务的机制。\n\n环境：Ubuntunano 1.cp\n\nint main(void)&#123;return 0；&#125;\n\ng++ 1.cpp\n\n./a.out\n\n名称空间名称空间支持是一项C++特性，旨在让您编写大型程序以及将多个厂商现有的代码组合起来的程序时更容易，它还有助于组织程序。一个潜在的问题是，可能使用两个已封装好的产品，而它们都包含一个名为wanda()的函数。这样，使用wanda()函数时，编译器将不知道指的是哪个版本。名称空间让厂商能够将其产品封装在一个叫做名称空间的单元中,这样就可以用名称空间的名称来指出想使用哪个厂商的产品因此，Microflop Industries可以将其定义放到一个名为Microflop的名称空间中。这样，其 wanda()函数的全称为Microflop;.wanda( );同样，Piscine公司的 wanda()版本可以表示为Piscine..wanda()。这样，程序就可以使用名称空间来区分不同的版本了:\nMicroflop: : wanda ( &quot;go dancing?&quot;);// use Microflop namespace versionPiscine: : wanda ( &quot;a fish named Desire&quot;); // use Piscine namespace version\n\n \nC++源代码风格虽然C++在格式方面赋予了您很大的自由，但如果遵循合理的风格，程序将更便于阅读。有效但难看的代码不会令人满意。多数程序员都使用程序清单2.1所示的风格，它遵循了下述规则。\n每条语句占一行。\n每个函数都有一个开始花括号和一个结束花括号，这两个花括号各占一行。函数中的语句都相对于花括号进行缩进。\n与函数名称相关的圆括号周围没有空白。\n前三条规则旨在确保代码清晰易读;第四条规则帮助区分函数和一些也使用圆括号的C++内置结构(如循环)。\n","categories":["编程"],"tags":["c++","基础"]},{"title":"c++ primer plus 03","url":"/2022/07/16/c-primer-plus-03/","content":"第3章 处理数据3.1 简单变量3.1.1 变量名命名规则\n在名称中只能使用字母字符、数字和下划线(_)。\n名称的第一个字符不能是数字。\n区分大写字符与小写字符。\n不能将C++关键字用作名称。\n\n3.1.2 整型char、short、int、long、long long\n3.1.3 运算符sizeof() + 头文件climitssizeof()sizeof()返回字节数，括号里可以是类型名，也可以是变量名。\n\n头文件climits头文件climits定义了符号常量来表示类型的限制。\n\n\n初始化（C语言和C++）C++11初始化方式（不推荐）\n3.1.4 无符号类型unsigned + 预处理语句#define（类似宏定义）只有当数值不会为负时才可以使用无符号类型，如人口、粒数等。注意：只写一个unsigned就默认表示unsigned int。\n\n3.1.5 数据类型选择\n\n3.1.6 不同的进制数（二进制、八进制、十六进制）不管值是10、012还是0xA，最终都以二进制的形式存储在计算机中。\n用cout输入不同进制（默认输出十进制）#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main()&#123;//用cout输出不同进制：\tint m = 26;\tcout &lt;&lt; dec &lt;&lt; &quot;26的十进制数是：&quot; &lt;&lt; m &lt;&lt; endl;//26\tcout &lt;&lt; hex &lt;&lt; &quot;26的十六进制数是：&quot; &lt;&lt; m &lt;&lt; endl;//1a\tcout &lt;&lt; oct &lt;&lt; &quot;26的八进制数是：&quot; &lt;&lt; m &lt;&lt; endl;//32\tcout &lt;&lt; &quot;26的二进制数是：&quot; &lt;&lt; bitset&lt;sizeof(int) * 2&gt;(m) &lt;&lt; endl;//00011010\treturn 0;\t&#125;\n\n3.1.7 C++如何确定常量的类型后缀是l或L：long常量后缀是u或U：unsigned int常量后缀是ul或lu或LU或UL：unsigned long常量\n3.1.8 char类型—C++转义字符列C++转义序列的编码表\n三种实现换行的代码\nsigned char 和 unsigned charchar用作数值类型：unsigned char：0255signed char：-128127char用作字符类型：有无符号都行。\n\n3.1.9 bool类型bool flag = true;//真flag = false;//假bool flag1 = 10;//真flag1 = -2;//假\n3.2 const限定符—定义符号常量用const定义符号常量，比#define要好；用const创建符号常量时要同时进行初始化，const int m = 10; 这样m就不能再变了。\n\n3.3 浮点数3.3.1 书写方式第一种是常用的标准小数点表示法;\n\n第二种是E表示法：\n\n3.3.2 浮点数类型—float 和 doubleC++对于有效位数（即精确度）的要求是：float至少32位；double至少48位，且不少于float；long double至少和double一样多。通常，float为32位（4字节），double为64位（8字节）。\nfloat的精度比double低，系统确保float至少有6位有效位，double至少有13位是精确的。\n这两段话一个说float的有效位数是32位，一个又说float至少有6位有效位，这是怎么回事呢？答：两种说法都没错，第一段的32位是指二进制的位数，第二段的6位是指十进制的位数。\n3.3.3 浮点常量\n3.3.4 浮点数的优缺点（代码见home/reus/Documents/C++_Primer_Plus/2#/6.cpp）优点：①可以表示整数之间的值；②可以表示的范围更大。缺点：运算速度慢，并且在运算过程中精度会降低\n","categories":["编程"],"tags":["c++","基础"]},{"title":"启用或禁用笔记本自带键盘","url":"/2022/07/17/%E5%90%AF%E7%94%A8%E6%88%96%E7%A6%81%E7%94%A8%E7%AC%94%E8%AE%B0%E6%9C%AC%E8%87%AA%E5%B8%A6%E9%94%AE%E7%9B%98/","content":"启用或禁用笔记本自带键盘使用方法使用管理员身份打开cmd，再复制以下命令回车，执行完之后提示“【SC】ChangeServiceConfig 成功” 即可，重启笔记本后生效\n\n启用\nsc config i8042prt start=demand\n\n\n上面的启用无效可以用下面的\nsc config i8042prt start= auto\n\n\n禁用\nsc config i8042prt start=disabled\n\n\n","categories":["杂项"],"tags":["小技巧"]},{"title":"浮点数在内存中如何存储","url":"/2022/07/11/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%AD%98%E5%82%A8/","content":"浮点数在内存中如何存储一、存储准则根据国际标准IEEE，任意一个二进制浮点数可以表示成下面的形式：\n(-1)^S * M * 2^E(-1)^s表示符号位，当s=0，V为正数；当s=1，V为负数。M表示有效数字，大于等于1，小于2。2^E表示指数位。\n\n\n\n二：浮点数的存储与读取方式（一）将浮点数存储进内存\nS：正数就是(-1)^0，负数则是(-1)^1。M：M一定属于 [1,2) ，M中小数点前面必然是1，因此1存储在内存中无意义 (如果把1存储进内存反而多占了一位，会降低所保存数字的精度) 。其实只需要在内存中保存小数点后面的几位数字即可。E：IEEE规定为E开辟的空间只可以存储无符号整数，但是实际上E却可能是负数，比如0.5。因此IEEE规定E的真实值必须加上一个中间值(8位的E中间值为127，11位的为1023)，在读取这个浮点数时又重新减去再减去中间值。\n\n（二）将浮点数从内存中拿出1.E不全为0或者不全为1\nS：直接拿出。M：从内存中拿出后在前面加上1和小数点E：减去中间值。\n\n2.E全为0\n E：E = 1-127 = -126(或者1-1023)M：M前面不加1而是加0。这样实际上是为了表示+-0与接近于0的很小的数字\n\n3.E全为1\nS：直接拿出。M：从内存中拿出后在前面加上1和小数点E：减去中间值。如果有效数字M全为0，表示±无穷大（正负取决于符号位s）\n\n\n\n三、图解与举例\n\n四、代码练习练习题\n底下这个代码输出结果是什么呢？\nint main()&#123; int n = 9; float *pFloat = (float *)&amp;n; printf(&quot;n的值为：%d\\n&quot;,n); printf(&quot;*pFloat的值为：%f\\n&quot;,*pFloat); *pFloat = 9.0; printf(&quot;num的值为：%d\\n&quot;,n); printf(&quot;*pFloat的值为：%f\\n&quot;,*pFloat); return 0;&#125;\n\n\n答案\nn的值为：9*pFloat的值为：0.000000num的值为：1091567616*pFloat的值为：9.000000请看下面解析#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123;\tint n = 9;\t//00000000000000000000000000001001 正数原码=反码=补码\t//0 00000000 00000000000000000001001\t//S    E             M\\\t//E全为0，直接用1-127=-126\t//M = 0.00000000000000000001001\t//S = 0\t//(-1)^0 * 0.00000000000000000001001 * 2^(-126)\t//0.0000000000…………(很小的数字)\t//\tfloat *pFloat = (float *)&amp;n;\tprintf(&quot;n的值为：%d\\n&quot;, n);//9\tprintf(&quot;*pFloat的值为：%f\\n&quot;, *pFloat);//0.0000000000…………(很小的数字)\t*pFloat = 9.0;\t//9.0\t//1001.0\t//1.001 * 2^3\t//(-1)^0 * 1.001 * 2^3\t//存取\t//S = 0\t//M = 1.001\t//E = 3\t//E =  3 +127 = 130\t//0 10000010 00100000000000000000000\t//本来以浮点数打印是没有问题的，但是这里却要求我们用整数的形式打印。\t//01000001000100000000000000000000\t//直接将这个二进制转换成十进制的整数\t//1,091,567,616\tprintf(&quot;num的值为：%d\\n&quot;, n);//1,091,567,616\tprintf(&quot;*pFloat的值为：%f\\n&quot;, *pFloat);//9.0\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n","categories":["编程"],"tags":["c++","基础"]},{"url":"/2022/07/15/%E7%AC%AC3%E7%AB%A0%20%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE/","content":"第3章 处理数据3.1 简单变量3.1.1 变量名命名规则\n在名称中只能使用字母字符、数字和下划线(_)。\n名称的第一个字符不能是数字。\n区分大写字符与小写字符。\n不能将C++关键字用作名称。\n\n3.1.2 整型char、short、int、long、long long\n3.1.3 运算符sizeof() + 头文件climitssizeof()sizeof()返回字节数，括号里可以是类型名，也可以是变量名。\n\n头文件climits头文件climits定义了符号常量来表示类型的限制。\n\n\n初始化（C语言和C++）C++11初始化方式（不推荐）\n3.1.4 无符号类型unsigned + 预处理语句#define（类似宏定义）只有当数值不会为负时才可以使用无符号类型，如人口、粒数等。注意：只写一个unsigned就默认表示unsigned int。\n\n3.1.5 数据类型选择\n\n3.1.6 不同的进制数（二进制、八进制、十六进制）不管值是10、012还是0xA，最终都以二进制的形式存储在计算机中。\n用cout输入不同进制（默认输出十进制）#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main()&#123;//用cout输出不同进制：\tint m = 26;\tcout &lt;&lt; dec &lt;&lt; &quot;26的十进制数是：&quot; &lt;&lt; m &lt;&lt; endl;//26\tcout &lt;&lt; hex &lt;&lt; &quot;26的十六进制数是：&quot; &lt;&lt; m &lt;&lt; endl;//1a\tcout &lt;&lt; oct &lt;&lt; &quot;26的八进制数是：&quot; &lt;&lt; m &lt;&lt; endl;//32\tcout &lt;&lt; &quot;26的二进制数是：&quot; &lt;&lt; bitset&lt;sizeof(int) * 2&gt;(m) &lt;&lt; endl;//00011010\treturn 0;\t&#125;\n\n3.1.7 C++如何确定常量的类型后缀是l或L：long常量后缀是u或U：unsigned int常量后缀是ul或lu或LU或UL：unsigned long常量\n3.1.8 char类型—C++转义字符列C++转义序列的编码表\n三种实现换行的代码\nsigned char 和 unsigned charchar用作数值类型：unsigned char：0255signed char：-128127char用作字符类型：有无符号都行。\n\n3.1.9 bool类型bool flag = true;//真flag = false;//假bool flag1 = 10;//真flag1 = -2;//假\n3.2 const限定符—定义符号常量用const定义符号常量，比#define要好；用const创建符号常量时要同时进行初始化，const int m = 10; 这样m就不能再变了。\n\n3.3 浮点数3.3.1 书写方式第一种是常用的标准小数点表示法;\n\n第二种是E表示法：\n\n3.3.2 浮点数类型—float 和 doubleC++对于有效位数（即精确度）的要求是：float至少32位；double至少48位，且不少于float；long double至少和double一样多。通常，float为32位（4字节），double为64位（8字节）。\nfloat的精度比double低，系统确保float至少有6位有效位，double至少有13位是精确的。\n这两段话一个说float的有效位数是32位，一个又说float至少有6位有效位，这是怎么回事呢？答：两种说法都没错，第一段的32位是指二进制的位数，第二段的6位是指十进制的位数。\n3.3.3 浮点常量\n3.3.4 浮点数的优缺点（代码见home/reus/Documents/C++_Primer_Plus/2#/6.cpp）优点：①可以表示整数之间的值；②可以表示的范围更大。缺点：运算速度慢，并且在运算过程中精度会降低\n"}]