[{"title":"Linux系统编程01","url":"/2023/05/05/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B01/","content":"程序：源代码，指令\n进程：运行的程序的实例化\n线程： 由进程引发的，线程属于进程，一个进程可以有多个线程，线程之间共享之间进程的资源\n任务：具体要做的事情， \nman getpid\n\n#in\n\n","tags":["Linux"]},{"title":"Markdown","url":"/2021/04/28/Markdown/","content":"简介Markdown 是一种轻量级标记语言，它用简洁的语法代替排版，使我们专心于码字。它的目标是实现易读易写，成为一种适用于网络的书写语言。同时，Markdown支持嵌入html标签。\n注意：Markdown使用#、+、*等符号来标记， 符号后面必须跟上 至少1个 空格才有效！\nMarkdown的常用语法标题Markdown 标题支持两种形式：\n1、用#标记\n在 标题开头 加上1~6个#，依次代表一级标题、二级标题….六级标题\n# 一级标题## 二级标题### 三级标题##### 四级标题###### 五级标题###### 六级标题\n\n2、用=和-标记\n在 标题底下 加上任意个=代表一级标题，-代表二级标题\n一级标题======二级标题----------\n\n效果如下：\n一级标题二级标题三级标题四级标题五级标题六级标题\n列表Markdown 支持有序列表和无序列表。\n无序列表使用-、+和\\*作为列表标记：\n- Red- Green- Blue* Red* Green* Blue+ Red+ Green+ Blue\n\n效果如下：\n\nRed\nGreen\nBlue\n\n有序列表则使用数字加英文句点.来表示：\n1. Red2. Green3. Blue\n\n效果如下：\n\nRed\nGreen\nBlue\n\n\n引用引用以&gt;来表示，引用中支持多级引用、标题、列表、代码块、分割线等常规语法。\n常见的引用写法：\n&gt; 这是一段引用    //在`&gt;`后面有 1 个空格&gt; &gt;     这是引用的代码块形式    //在`&gt;`后面有 5 个空格&gt;     &gt; 代码例子：&gt;       protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);    &#125;&gt; 一级引用&gt; &gt; 二级引用&gt; &gt; &gt; 三级引用&gt; #### 这是一个四级标题&gt; &gt; 1. 这是第一行列表项&gt; 2. 这是第二行列表项\n\n效果如下：\n\n这是一段引用\n这是引用的代码块形式    //在`&gt;`后面有 5 个空格\n\n代码例子：\n\nprotected void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);&#125;\n\n\n一级引用\n\n二级引用\n\n三级引用\n\n\n\n\n这是一个四级标题\n这是第一行列表项\n这是第二行列表项\n\n以下是分割线\n\n\n强调两个*或-代表加粗，一个*或-代表斜体，~~代表删除。\n**加粗文本** 或者 __加粗文本__*斜体文本*  或者_斜体文本_~~删除文本~~\n\n效果如下：\n加粗文本 或者 加粗文本\n斜体文本 或者 斜体文本\n删除文本\n\n图片与链接图片与链接的语法很像，区别在一个 ! 号。二者格式：\n图片：![]()    ![图片文本(可忽略)](图片地址)链接：[]()     [链接文本](链接地址)\n\n链接又分为行内式、参考式和 自动链接：\n这是行内式链接：[ConnorLin&#x27;s Blog](http://connorlin.github.io)。这是参考式链接：[ConnorLin&#x27;s Blog][url]，其中url为链接标记，可置于文中任意位置。[url]: http://connorlin.github.io/ &quot;ConnorLin&#x27;s Blog&quot;链接标记格式为：[链接标记文本]:  链接地址  链接title(可忽略)这是自动链接：直接使用`&lt;&gt;`括起来&lt;http://connorlin.github.io&gt;这是图片：![][avatar][avatar]: https://connorlin.github.io/images/avatar.jpg\n\n效果如下：\n这是行内式链接：ConnorLin’s Blog。\n这是参考式链接：ConnorLin’s Blog，其中url为链接标记，可置于文中任意位置。\n这是自动链接：直接使用&lt;&gt;括起来http://connorlin.github.io\n这是图片：\n\n\n代码代码分为行内代码和代码块。\n\n行内代码使用 代码 标识，可嵌入文字中\n\n代码块使用4个空格或&#96;&#96;&#96;标识\n`&#96;&#96; 这里是代码 `&#96;&#96;\n\n代码语法高亮在 &#96;&#96;&#96;后面加上空格和语言名称即可\n`&#96;&#96; 语言 &#x2F;&#x2F;注意语言前面有空格 这里是代码 `&#96;&#96;\n\n\n例如：\n这是行内代码`onCreate(Bundle savedInstanceState)`的例子。这是代码块和语法高亮：``` java// 注意java前面有空格protected void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);&#125;```\n\n效果如下：\n这是行内代码onCreate(Bundle savedInstanceState)的例子。\n这是代码块和语法高亮：\n// 注意java前面有空格protected void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);&#125;\n\n表格表格对齐格式\n\n居左：:----\n居中：:----:或-----\n居右：----:\n\n例子：\n|标题|标题|标题||:---|:---:|---:||居左测试文本|居中测试文本|居右测试文本||居左测试文本1|居中测试文本2|居右测试文本3||居左测试文本11|居中测试文本22|居右测试文本33||居左测试文本111|居中测试文本222|居右测试文本333|\n\n效果如下：\n\n\n\n标题\n标题\n标题\n\n\n\n居左测试文本\n居中测试文本\n居右测试文本\n\n\n居左测试文本1\n居中测试文本2\n居右测试文本3\n\n\n居左测试文本11\n居中测试文本22\n居右测试文本33\n\n\n居左测试文本111\n居中测试文本222\n居右测试文本333\n\n\n\n分隔线在一行中用三个以上的*、-、_来建立一个分隔线，行内不能有其他东西。也可以在符号间插入空格。\n***---___* * *\n\n效果均为一条分割线：\n\n\n换行在行尾添加两个空格加回车表示换行：\n这是一行后面加两个空格  换行\n\n效果如下：\n这是一行后面加两个空格 换行\n\n脚注(注解)使用[^]来定义脚注：\n这是一个脚注的例子[^1][^1]: 这里是脚注\n\n效果如下：\n这是一个脚注的例子[1]\n\n常用弥补Markdown的Html标签字体&lt;font face=&quot;微软雅黑&quot; color=&quot;red&quot; size=&quot;6&quot;&gt;字体及字体颜色和大小&lt;/font&gt;&lt;font color=&quot;#0000ff&quot;&gt;字体颜色&lt;/font&gt;\n\n效果如下：\n字体及字体颜色和大小 字体颜色\n\n换行使用html标签`&lt;br/&gt;`&lt;br/&gt;换行\n\n效果如下：\n使用html标签&lt;br/&gt;换行\n\n文本对齐方式&lt;p align=&quot;left&quot;&gt;居左文本&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;居中文本&lt;/p&gt;&lt;p align=&quot;right&quot;&gt;居右文本&lt;/p&gt;\n\n效果如下：\n居左文本 居中文本 居右文本\n\n\n下划线&lt;u&gt;下划线文本&lt;/u&gt;\n\n效果如下：\n下划线文本\n"},{"title":"NAS","url":"/2023/05/03/NAS/","content":"title: 时钟date: 2023-04-28 00:21:45tags:\n\n\n\n一、概述众所周知在办公的时候两台电脑之间经常倒数据资料非常麻烦，而NAS可以很好的解决这个问题。树莓派搭建NAS方法有很多，我们之前也拍过直接用Samba、FTP这些来实现NAS功能，但是这些需要你会在命令行进行配置，而且对于新手用起来并不直观方便对于一个NAS系统来说功能也不全，故我们这次用开源的OMV来搭建NAS系统！\n目前网上普遍的OMV搭建NAS的教程都比较老了，照着做会出现各种问题，而我们本期教程是在最新树莓派官方系统上做的，大家照着做完全不会有问题，本期的精简视频教程在B站-杨坤树莓派爱好者基地中可以看到，VLOG全程记录视频可以在B站-玩派VLOG看到，欢迎大家三连～\n视频教程地址：哔哩哔哩bilibili：树莓派爱好者基地视频VLOG记录：哔哩哔哩bilibili：玩派VLOG\n\n二、教程内容1、树莓派安装系统这里我们用到的是最新的树莓派官方精简版系统（不能使用带桌面的版本！）记得点这个设置，在里面需要开启SSH、设置pi账户的密码、配置WIFI的账号和密码\n2、固定静态IP打开路由器后台查看树莓派IP地址在ssh软件中输入下面命令，配置DHCP文件\nsudo nano /etc/dhcpcd.conf\n\n文件中这个位置按照你自己的情况进行修改然后重启树莓派\nsudo reboot\n\n3、换源sudo nano /etc/apt/sources.list\n\n把原来的注视掉，把下面的复制进去\ndeb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ bullseye main non-free contrib rpideb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ bullseye main non-free contrib rpi\n\n继续\nsudo nano /etc/apt/sources.list.d/raspi.list\n\n把原来的注视掉，把下面的复制进去\ndeb https://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ bullseye main ui\n\n然后记得更新一下\nsudo apt-get updatesudo apt-get upgrade\n\n4、安装OMVwget  https://cdn.jsdelivr.net/gh/OpenMediaVault-Plugin-Developers/installScript@master/installchmod +x installsudo ./install -n\n\n5、配置OMV浏览器输入树莓派IP地址就可以进入NAS系统了。\n用户名默认为admin，密码为openmediavault\n\n首先在系统设置-工作台里面设置一下登出时间，之前的太短了把硬盘插在树莓派上，然后快速擦除磁盘创建文件系统挂载创建共享文件夹配置SMB服务配置一下一般登陆的用户pi\n6、开始使用WINDOWS上直接添加一个映射\n本文转自 https://blog.csdn.net/qq_41676577/article/details/128063914?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170943694416800180656833%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170943694416800180656833&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-128063914-null-null.142^v99^pc_search_result_base7&amp;utm_term=%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BAnas&amp;spm=1018.2226.3001.4187，如有侵权，请联系删除。\n"},{"title":"博途_定时器","url":"/2024/05/13/%E5%8D%9A%E9%80%94-%E5%AE%9A%E6%97%B6%E5%99%A8/","content":""},{"title":"时钟","url":"/2023/04/28/%E6%97%B6%E9%92%9F/","content":"STM32_RCC系统原理图框图RCC ：reset clock control 复位和时钟控制器\n\nSTM32共有五个时钟源，分别是HSI、HSE、LSI、LSE和PLL ，下面分别对它们进行讲解：\n①、HSI是高速内部时钟，RC振荡器，频率为8MHz，精度不高。　\n②、HSE是高速外部时钟，可接石英&#x2F;陶瓷谐振器，或者接外部时钟源，频率范围为4MHz~16MHz。\n③、LSI是低速内部时钟，RC振荡器，频率为40kHz，提供低功耗时钟。独立看门狗的时钟源只能是 LSI ，同时LSI 还可以作为 RTC 的时钟源。④、LSE是低速外部时钟，接频率为32.768kHz的石英晶体。是主要的RTC时钟源。⑤、PLL为锁相环倍频输出，其时钟输入源可选择为HSI&#x2F;2、HSE或者HSE&#x2F;2。倍频可选择为2~16倍，但是其输出频率最大不得超过72MHz。\n注意：高速外部时钟HSE的引脚是OSC_OUT和OSC_IN这两个引脚芯片是独立引出的，可以接外部的晶振电路，而低速外部时钟LSE的引脚OSC32_IN和OSC32_OUT两个引脚不是独立的。\n时钟去向\nA   MCO 是 STM32 的一个时钟输出 IO(PA8) PA8)，它可以选择一个时钟信号输出 可以选择为 PLL 输出的 2 分频、 HSI 、 HSE 、或者 系统 时钟 。这个时钟可以用来给外部其他系统提供时钟源。\n\n\nB   RTC 时钟源，从图上可以看出， RTC 的时钟源可以选择 LSI LSE ，以及HSE 的 128 分频。\n\n\nC   从图中可以看出 C 处 USB 的时钟是来自 PLL 时钟源。 STM32 中有一个全速 功能的 USB 模块 ，其串行 接口 引擎需要 一个频率为 48MHz 的时钟源。该时钟源只能从 PLL 输出端获取，可以选择为 1.5 分频或者 1 分频，也就是，当需要使用 USB模块时， PLL 必须使能，并且时钟频率配置为 48MHz 72MHz。\n\n\nD   STM32 的系统时钟 SYSCLK ，它 是供 STM32 中绝大部分部件 工作 的时钟源 。 系统时钟可选择为 PLL 输出、 HSI 或者 HSE 。系统时钟最大频率 为 72MHz当然你也可以超频，不过一般情况为了系统稳定性是没有必要冒风险去超频的。\n\n\nE   其他所有外设。从时钟图上可以看出，其他所有外设的时钟最终来源都是 SYSCLK 。 SYSCLK 通过 AHB 分频器分频后送给各模块使用 。这些模块包括：① AHB 总线、内核、内存和 DMA 使用的 HCLK 时钟。② 通过 8 分频后送给 Cortex 的系统 定时器 时钟 ，也就是 systick 了 。③ 直接送给 Cortex 的空闲运行时钟 FCLK 。④ 送给 APB1 分频器。 APB1 分频器输出一路供 APB1 外设使用 (PCLK1 ，最大频率 36MHz)36MHz)，另一路送给定时器 (Timer)2 、 3 、 4 倍频器使用。⑤送给 APB2 分频器。 APB2 分频器分频输出一路供 APB2 外设使用 (PCLK2最大频率 72MHz)72MHz)，另一 路送给定时器 (Timer)1 倍频器使用。        APB1和APB2的区别： APB1上面连的是低速外设，包括电脑接口、备份接口、CAN、USB、I2C1、I2C2 、 UART2 、 UART3 等等， APB2 上面连接的是高速外设包括 UART1 、 SPI1 、 Timer1 、 ADC1 、 ADC2 、所有普通 IO 口 (PA~ 、第二功能 IO 口 等。 APB2 下面所挂的外设的时钟要比 APB1 的高 。\n\n在以上的时钟输出中，有很多是带使能控制的，例如 AHB 总线 时钟、内核时钟、各种 APB1外设、 APB2 外设等等。需要使用某模块时要先使能对应的时钟。\nSTM32时钟配置"},{"title":"类","url":"/2024/03/23/%E7%B1%BB/","content":"一、”类” 的介绍对象：对象是对现实世界中的事物或概念的抽象表示。在C++中，对象是由类创建的实体。对象包含数据（属性或成员变量）和对这些数据进行操作的方法（成员函数）。\n实例：实例是类的具体对象。当你使用类的构造函数创建一个对象时，你就创建了一个类的实例。每个实例都有其自己的数据成员（即属性）和可以调用其成员函数（即方法）。\n属性：属性是对象的特性或状态，它们存储对象的数据。在C++中，这些通常被称为成员变量或数据成员。\n方法：方法是对象可以执行的操作或行为。在C++中，这些被称为成员函数。它们通常用于修改对象的属性或基于对象的属性执行某些计算\n1.      类的声明class 类名称&#123;public:     公有成员（外部接口）private:     私有成员 （只允许本类中的函数访问，而类外部的任何函数都不能访问）protected:     保护成员（与private类似，差别表现在继承与派生时）&#125;;\n\n#include &lt;iostream&gt;using namespace std;class Test&#123;public:    int x_;    void init(int x, int y,int z);    void display()    &#123;        cout&lt;&lt; x_ &lt;&lt; endl;    &#125;;private:    int y_;protected:    int z_;&#125;; void Test::init(int x, int y, int z)&#123;    x_ = x;    y_ = y;    z_ = z;&#125;int main()&#123;    Test t;    t.init(1,2,3);    t.display();    return 0;&#125;\n\nclass Car &#123;  private:      std::string color;      std::string make;      std::string model;      int year;    public:      // 构造函数      Car(std::string c, std::string m, std::string mod, int y) : color(c), make(m), model(mod), year(y) &#123;&#125;        // 方法      void start() &#123;          // 实现启动汽车的逻辑      &#125;        void stop() &#123;          // 实现停止汽车的逻辑      &#125;        // ... 其他方法和属性 ...  &#125;;    int main() &#123;      // 创建Car类的一个实例      Car myCar(&quot;Red&quot;, &quot;Toyota&quot;, &quot;Corolla&quot;, 2020);            // 使用myCar的方法      myCar.start();      // ... 其他操作 ...      myCar.stop();        return 0;  &#125;\n\n\n"}]